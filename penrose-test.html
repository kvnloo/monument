<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penrose Triangle Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #E6D5C3;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Penrose Triangle - Impossible Geometry</strong><br>
        Three perpendicular beams that appear to form<br>
        a closed triangle from this viewing angle.<br>
        The illusion breaks when rotated!<br><br>
        <span id="status">Ready</span>
    </div>
    <div id="controls">
        <strong>Controls:</strong><br>
        SPACE - Toggle rotation (reveals the trick!)<br>
        R - Reset to illusion view
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE6D5C3);

        // Orthographic camera (isometric view)
        const aspect = window.innerWidth / window.innerHeight;
        const d = 20;
        const camera = new THREE.OrthographicCamera(
            -d * aspect, d * aspect, d, -d, 1, 1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ========================================
        // PENROSE TRIANGLE - PROPER CONSTRUCTION
        // Based on research from working Three.js implementations
        // Three perpendicular beams with strategic positioning
        // ========================================

        const origin = { x: 3.5, y: 0, z: 0 };
        const colors = [0xE89B7B, 0x4A7A8C, 0x8B9A8E];

        const penroseGroup = new THREE.Group();
        scene.add(penroseGroup);

        // Helper function to create and position a beam
        function createBeam(dimensions, offset, color) {
            const geometry = new THREE.BoxGeometry(dimensions.width, dimensions.height, dimensions.depth);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(geometry, material);

            // Position beam
            beam.position.set(
                origin.x + offset.x,
                origin.y + offset.y,
                origin.z + offset.z
            );

            // Add black edges for better definition
            const edges = new THREE.EdgesGeometry(geometry);
            const edgeLine = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0x000000 })
            );
            beam.add(edgeLine);

            return beam;
        }

        // Create the three beams that form the Penrose triangle
        // Each beam is perpendicular to the others and positioned strategically

        // Beam 1: Vertical beam (along Z-axis)
        const beam1 = createBeam(
            { width: 1, height: 1, depth: 16 },
            { x: 0, y: 0, z: 0 },
            colors[0]
        );
        penroseGroup.add(beam1);

        // Beam 2: Horizontal beam left (along Y-axis)
        const beam2 = createBeam(
            { width: 1, height: 14, depth: 1 },
            { x: 0, y: 7.5, z: 7.5 },
            colors[1]
        );
        penroseGroup.add(beam2);

        // Beam 3: Horizontal beam right (along X-axis)
        const beam3 = createBeam(
            { width: 16, height: 1, depth: 1 },
            { x: -7.5, y: 0, z: -7.5 },
            colors[2]
        );
        penroseGroup.add(beam3);

        // Apply rotation to view from the critical angle where the illusion works
        // From this angle, the three beams appear to form an impossible triangle
        penroseGroup.rotation.x = Math.PI / 6;  // 30 degrees
        penroseGroup.rotation.y = -Math.PI / 4; // -45 degrees

        // Center the group
        penroseGroup.position.set(-3, 0, 0);

        // Optional: Add rotation to reveal the illusion
        let autoRotate = false;
        let rotationSpeed = 0.005;

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            if (event.key === ' ') {
                autoRotate = !autoRotate;
                document.getElementById('status').textContent =
                    autoRotate ? 'Rotating (press SPACE to stop)' : 'Stopped (press SPACE to rotate)';
            }
            if (event.key === 'r' || event.key === 'R') {
                // Reset to illusion view
                penroseGroup.rotation.x = Math.PI / 6;  // 30 degrees
                penroseGroup.rotation.y = -Math.PI / 4; // -45 degrees
                autoRotate = false;
                document.getElementById('status').textContent = 'Reset to illusion view';
            }
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate) {
                penroseGroup.rotation.y += rotationSpeed;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('status').textContent = 'Ready! Press SPACE to rotate';
    </script>
</body>
</html>
